усовершенствованная память переводов
или машинный переводчик с открытым словарем фраз и правил

=== вступление и мотивация ===
Чистый машинный перевод без вмешательства человека - тупиковый путь, т.к. на сегодняшний день (и скорее всего в дальнейшем) он не может обеспечить качество перевода, которое может обеспечить себе человек. Самая распространенная технология автоматизированного перевода - память переводов - слижком примитивна: 
ее суть в следующем: для каждого исходного предложения (а иногда даже абзаца) система запоминает перевод, выполненный человеком (возможно при помощи машинного переводчика), после чего, если вдруг встретиться такое же предложение, то система автоматически переведет его тем переводом, который был запомнен.
Если в преложении больше трех слов, то вероятность встретить в тексте 2 одинаковых предложения крайне мала.
(Конечно при переводе уже переведенного модифицированного текста помощь ощутимая, но этого мало.)
Для решения этой проблемы !предлагается! разбивать текст на фразы и подфразы, состоящие из очень небольшого числа слов и подфраз, но так, чтобы из этих подфраз автоматически конструировались предложения. Чтобы это было возможно, переводом каждой фразы исходного языка должна быть не фраза, а маленький алгоритм - правило - генерации фразы на целевом языке.
Однако для некоторых идиом языка, которые могут конструироваться из паттернов, можно будет делать "исключения", и для них задавать отдельные правила.
Имено поэтому необходим доступ пользователей для редактирования фраз и правил.

Даже сейчас, в период популярности нейронных сетей, их обучать довольно сложно (совсем неочевидно что там для себя сеть решит), и описанные здесь структуры отлично подойдут как основа для нейронных сетей.

=== общий алгоритм ===
И так, есть паттерны и правила.
Паттерны - предложения БНФ для разбора(парсинга) текста (их еще можно называть фразами).
Терминальные паттерны - те, которые не ссылаются на другие паттерны.
Примерами терминальных паттернов могут являться отдельные слова или словосочетания исходного языка.
Каждому терминальному паттерну соответствует "правило" которое всегда возвращает один и тот же результат - перевод паттерна - определенного типа.
Этим типом может являться часть речи (например существительное, прилагательное, глагол...), возможно уточненная вопросом к слову, который задает параметр части речи (род, число, падеж....).
Паттерн может иметь несколько типов - тех, какие возвращаются правилами, которыми он может переводиться (см. далее).
Нетерминальные паттерны - те, которые могут ссылаться на другие паттерны определенного типа.
(Если точнее, то можно считать, что они ссылаются на определенный тип, и можно считать, что тип - предложение БНФ вида ::=п1|п2|п3|... , где п1, п2, п3, ... - все паттерны, имеющие данный тип.)
Им соответствуют правила уже с аргументами.
Такое правило в качестве аргументов берет результаты правил, которые соответствуют паттернам, на которые сылается (через соответствующие типы) паттерн, который соответствует этому правилу.
(Конкретные паттерны, на которые ссылается данный паттерн, определяются в момент парсинга.)
После чего это правило может поменять например род/число/падеж полученных аргументов и сгенерировать результат опять некоторого типа.
Для удобства таких преобразований хорошо бы было, если бы результат получался в виде дерева слов...
Таким образом получается, что текст парсится как буд-то это текст на формальном языке, после чего по правилам генерируется его перевод.
-> таким образом обеспечивается линковка окончаний слов в предложении

	Также, между словами целевого языка возможны связи, которые позволяют правилам заменять одни слова на другие (например связи между глаголами и (дее)причястиями для замен типа летающий -> который летал).
	У пользователей должна быть возможность редактировать словоформы и связи между словами целевого языка.

=== способы влияния на систему ===
1)
В разных текстах одна и та же фраза может иметь разный смысл.
Следовательно, в разных текстах один и тот же паттерн может переводиться разными способами.
Для этого необходимо, чтобы каждому паттерну соответствовало несколько правил, а пользователь мог выбрать (например из выпадающего списка) для каждого паттерна каким правилом его переводить.
При этом, если пользователь для какого-то паттерна выбрал (или добавил) правило в одном месте текста, то в другом месте текста этот же паттерн должен переводиться этим же правилом.
(При выборе (или добавлении) варианта пользователю можно показать, в каких местах еще поменяется перевод...)
А также можно сделать перевод слов, набранных шрифтом, отличным от обычного, другим, так, чтобы переводчик по шрифту догадывался, например где код, а где обычный текст.
Чтобы для одного и того же текста разным пользователям при переводе не приходилось делать одни и те же выборы переводов, разумно будет сохранять эти выборы переводов, сопоставляя их URL-у исходного текста, и при повторном открытии этого текста через переводчик использовать запомненные выборы переводов.

Стоит отметить, что эта информация совсем не привязывается к конкретным предложениям текста, а лишь ко всему тексту в целом.
Это будем называть !памятью переводов! данного текста.
А паттерны и правила и их соответствия будем называть !словарем фраз! и их переводов исходного языка(+см. мультилингва).
А также, когда начинаешь переводить новый текст, памать переводов можно инициализировать от другого переведенного текста схожей тематики.
(А этот текст можно подобрать например на основе ключевых слов из этого текста...)

Возможно память переводов текстов (т.е. указание смысла нек. фраз) в дальнейшем можно будет использовать для индексирования текстов для дальнейшего интернет-поиска по ним с указанием конкретного смысла...

2)
Может быть, что некоторая фраза в контексте другой фразы переводится определенным образом. Тогда при выборе (или добавлении) варианта пользователь может указать, что выбранный способ перевода фразы должен использоваться всегда, когда эта фраза находится внутри надфразы, которой является текущая надфраза.
	Может оказаться, что некоторая фраза в контексте другой фразы, которая в контексте третьей фразы переводится определенным образом.
	Может оказаться, что надфраза переводится определенным образом только если в качестве первой подфразы идет определенная подфраза и в качестве второй - другая определенная подфраза.
	Может оказаться, что заданная составная фраза может переводится несколькими способами, один из которых - комбинация из всех исходных.
...
Чтобы это обобщить, фразу будем называть составной, если ее паттерн можно представить в виде
	нетерминальной фразы (ее будем называть основной (в составе составной)), где хотябы вместо одного типа используется 
	конкретная фраза этого типа (такие фразы будем называть зависимыми (в составе составной))
иначе фразу будем называть фразой 1-го уровня (простая фраза)
фраза n-го уровня состоит из фраз n-1-го и ниже уровней
а также, если фраза A является основной, а фразы B и C являются зависимыми в составе фразы X,
то со фразой A связана информация, ссылающаяся на фразы B,C и X

технически пасинг выглядит так:
текст (на клиенте) разбивается на слова, удаляются повторяющиеся слова, после чего на клиент загружаются все фразы 1го уровня, в которых эти слова встречаются
производится парсинг, после чего, какие-то фразы в тексте нашлись, 
и после этого на клиент загружются те фразы 2-го уровня, на которые ссылаются те фразы 1-го уровня, которые нашлись в тексте вместе с соответствующими зависимыми фразами.
в тексте ищутся фразы 2-го уровня в соответствующих местах...
и так далее
...
У пользователя должна быть возможность конструировать составные фразы и правила их перевода.
После этого во всех текстах для данной составной фразы по умолчанию будут предлагаться только соотв. варианты, но также будет возможность "отключить" эту составную фразу.
В текстах, которые были переведены раньше, чем в словарь фраз была добавлена составная фраза, эту фразу лучше особо выделять, если она дает перевод, отличный от того, который получался без этой составной фразы, чтобы читающему текст пользователю было проще находить и исправлять возможные ошибки перевода.
-> Таким образом обеспечивается единообразный перевод терминов, а также возможно конструкций и идиом языка.

	При выборе определенного правила для или создания составной фразы вокруг определенного слова (т.е. терминального паттерна) также было бы полезно автоматически это делать и для других форм этого слова (при этом спрашивая у пользователя, стоит ли это делать). Для этого нужно, чтобы между словами/паттернами исходного языка были связи, а у пользователей должна быть возможность редактировать эти связи.

2+)
Если окажется, что одна и та же часть текста может быть разобрана разными способами (разными конструкциями из паттернов), то по умолчанию она конечно будет переведена каким-то способом, но пользователю будет настоятельно предлагаться создать составную фразу.

3)
эстетический выбор.
Каждое правило генерирует перевод, имеющий определенный смысл.
При этом правило может генерировать разные переводы, имеющие один и тот же смысл.
Выбор между такими вариантами может осуществляться случайно, или с применением нейронных сетей или других эвристических методов например для устранения эстетически плохих ситуаций типа "масло масленое" и т.п.
При этом пользователю не допускается делать выбор между эстетическими вариантами перевода, но, если оно вдруг начинает нарушать смысл, должна быть возможность отредактировать список эстетических вариантов, генерируемых правилом.

4)
Одним из неучтенных моментов остаются слова-ссылки наподобие this, one, which ..., которые, перед тем как переводить, надо понять, на что они ссылаются (или хотябы род, число, падеж того, на что они ссылаются).

5)
Естественные языки намного более многогранны чем компьютерные, и учесть все нюансы заранее невозможно.
Чтобы было проще добавлять обработку таких нюансов, нужно создавать систему на гибком языке, например таком как javascript.
В общем - стратегия апгрейда такая: все что может быть автоматизировано - должно быть автоматизировано, но не больше. Для всего остального нужно сделать GUI.

=== мультилингва ===
Поскольку каждое правило перевода имеет один единственный смысл
то ему можно сопоставить алгоритмы генерации текста для разных целевых языков.
А также для разных исходных языков нужны будут свои фразы с алгоритмами парсинга.
Однако для одного исходного языка ссылки на составные фразы у разных целевых языков будут различаться.

=== создание словаря фраз ===
каждый раз, когда требуется внести изменение в перевод, надо выбрать одно из трех:
	изменить правило, т.к. в нем ошибка
	изменить смысл фразы во всем тексте (а также, возможно, выбрать диапазон декста -
		выбрать оптимальный размер памяти переводов - для абзаца/страницы/главы)
	создать новую составную фразу-исключение
- это достаточно сложно автоматизировать, особенно для языковых оборотов и идиом языка

по этому автоматическая генерация словаря фраз из существующих пар текстов на мой взгляд невозможна
максимум, что можно сделать автоматически - это загрузка существующих словарей слов и маленьких фраз/терминов (например из википедии)
остальное лучше предоставить пользователям в wiki-формате:
каждый может изменить словарь фраз, и в любой момент это изменение можно откатить
!можно пользователям предлагать составлять паттерны и правила для имеющихся переводов, да и самому попробовать, а там, глядишь и выработается алгоритм генерации НЕКОТОРЫХ фраз и правил из существующих пар текстов
Но у пользователей все равно должен быть доступ к словарю фраз и правил.

=== как лучше организовать ===
Поскольку хочется распространенности с одной стороны и единства базы данных (словаря фраз и правил а также памяти переводов) с другой, то лучше всего сделать в виде интернет-сервиса (браузерного приложения).
По скольку с одной стороны алгоритм не имеет большой алгоритмической сложности (по сути это парсер) а с другой - требует интерактивного вмешательства пользователя, то лучше всего реализовать процесс перевода на клиенте (в браузере) (вместе с кэшированием данных в LocalStorage браузера), ну а базу данных - на сервере.
Поскольку БД должна быть устойчива к вандальным правкам, то нужно что-то наподобие викидвижка для возможности отката и просмотра истории правок.
Если это будет mediawiki, то к нему надо будет сделать соотв. расширения для просмотра и редактирования БД в wisiwig формате....

=== интернет-структура ===
взять викидвижок, и в нем хранить : паттерны, правила, правки текстов(по url-ам), описание всего проекта
веб-морда будет переводить сторонние сайты, беря паттерны, правила и правки текстов с викидвижка по специальному API.

=== бизнес-модель ===
аналог github-а
код веб-морды будет закрыт
информация, хранящаяся на викидвижке будет открыта как для редактирования, так и для скачивания
веб-морда будет беспалтно переводить открытые сайты в интернете
	и платно закрытый контент. Для него можно будет сделать отдельное хранилище.






дальше можно не читать









существует "технология" память переводов
ее суть в том, чтобы одинаковые предложения переводились одинаковым способом
Если мы таким образом перевели некоторый текст, то потом переводить модифицированную версию этого текста будет гораздо проще, 
	т.к. надо будет перевести только измененные предложения.
Но какова вероятность встретить два одинаковых предложения в разных текстах?
	Если в предложении больше трех слов, то практически нулевая.
	
в этом тексте память переводов используется с другим смыслом
Предлагается сделать переводчик в котором единицей перевода будет не предложение, а фраза
	(словосочетания, слова - тоже являются фразами)
	причем английской фразе будет будет сопоставляться не ее перевод, а правило (алгоритм) генерации перевода
		фраза и правило перевода могут быть как очень простыми, так и очень сложными
	у одной и той же фразы может быть несколько смыслов, и соответственно, правил перевода
	совокупность фраз со всеми их правилами перевода - "память переводов" уровня языка - или проще говоря словарь фраз
в каждом конкретном тексте некоторая фраза имеет только один смысл (возможно с редкими исключениями)
	и выбор для каждой фразы варианта ее перевода из имеющихся - память переводов данного текста

==============================================================================

есть словарь фраз
есть память переводов (для каждого текста)

=== парсинг ===
(мульти)словарь фраз - ссылки от фраз на правила перевода
мульти - одна фраза может ссылаться на несколько правил
на одно правило перевода может идти несколько фраз

паттерн - БНФ
фраза - паттерн, который может использовать паттерны (также как одно предложение БНФ может использовать другие предложения), 
	называющиеся "типы (под)фраз",
тип подфразы - паттерн ИЛИ, использующий все фразы, имеющие этот тип (ф1 | ф2 | ф3 | ф4 | ...)
каждая фраза имеет один или несколько типов - сущ/глаг/прил/ или другая часть речи, которая может уточняться вопросом
типы фразы определяются типами правил, которыми может переводиться эта фраза

парсинг текста происходит по предложениям***
предложение парсится по очереди типами фраз, начиная с глагольного (или стартовым паттерном, который который использует другие фразы)

фразу будем называть терминальной или лексической, если ее паттерн не использует типы фраз
	примеры: [cat]; [fat]/*жирный*/
иначе фразу будем называть синтаксической или грамматической
	пример: [<прил> cat]
простые синтаксические фразы можно называть лексико-синтаксическими

фразу будем называть составной, если ее паттерн можно представить в виде
	синтаксической фразы (ее будем называть основной (в составе составной)), где хотябы вместо одного типа используется 
	конкретная фраза этого типа (такие фразы будем называть зависимыми (в составе составной))
		пример: [fat cat]
иначе фразу будем называть фразой 1-го уровня (простая фраза)
фраза n-го уровня состоит из фраз n-1-го и ниже уровней
а также, если фраза A является основной, а фразы B и C являются зависимыми в составе фразы X,
то со фразой A связана информация, ссылающаяся на фразы B,C и X

технически пасинг выглядит так:
текст (на клиенте) разбивается на слова, удаляются повторяющиеся слова, после чего на клиент загружаются все фразы 1го уровня, в которых эти слова встречаются
производится парсинг, после чего, какие-то фразы в тексте нашлись, 
и после этого на клиент загружются те фразы 2-го уровня, на которые ссылаются те фразы 1-го уровня, которые нашлись в тексте вместе с соответствующими зависимыми фразами.
в тексте ищутся фразы 2-го уровня в соответствующих местах...
и так далее
	например есть фраза [fat] и фраза [<прил> cat]
	на тексте [the fat cat] они будут найдены, и следовательно загрузится состовная фраза [fat cat]
	после чего она будет найдена, и она перекроет конструкцию из фраз [fat] и  [<прил> cat]


? как добавлять новые фразы, и что делать если текст можно распарсить разными способами ?
во первых каждое отдельное слово - изначально существующая фраза
а также как можно раньше надо сделать как можно более правильные грамматические фразы, чтоб они разбивали предложение с наибольшей глубиной вложенности
при коллизии фраз (один и тот же текст можно распарсить разными способами)
	у них сразу должна создаться (возможно вручную) составная фраза, 
	с набором правил, который является объединением наборов правил фраз, учавствующих в коллизии
	...

> на этом этапе почти не учитываю морфологию(словоформы), т.е. русский текст так не распарсишь
	хотя нет, распарсишь, только потребуется гораздо больше типов, различающихся по родам/числам/падежам/др_параметрам
	только для единообразия и упрощения должна быть связь между разными формами одного и того же слова
	и в переводе при выборе смысла он должен меняться у всех форм

=== перевод ===
каждая фраза может иметь нескоько смыслов, и соответственно несколько правил перевода
каким образом переводить ту или иную фразу - ВЫБИРАЕТ пользователь МЫШКОЙ ИЗ ВЫПАДАЮЩЕГО СПИСКА
после выбора* (или добавления) некоторого правила для некоторой фразы это правило записывается в память переводов данного текста, 
	и всегда, когда встречается эта фраза в этом тексте она по умолчанию будет переводиться этим правилом
* если в каком-то месте надо сделать исключение для для фразы, то из надфразы этой фразы как основной и этой фразы как зависимой
	создается состовная фраза, и добавляется в словарь фраз, после чего ей сопоставляется правило, в котором указано, 
	какие конкретно правила вызывать для основной и зависимой фразы, 
	а также эта составная фраза с этим правилом добавляется в память переводов этого текста.
***, * если у фразы нет надфраз, т.е. эта фраза - целое предложение, то наверно надо делать фразы содержащие несколько предложений...

чтобы для каждого нового текста схожей тематики не создавать заново вручную память переводов,
	ее можно инициализировать от другого/других текстов

=== генерация ===
каждое правило перевода имеет тип и один единственный смысл этого типа
(текст, сгенерированный этим правилом, может иметь и другие смыслы, но один из них (по возможности главный и очевидный)
	должен быть тем, для которого предназначено это правило)
и возвращает текст этого типа ввиде дерева, чтобы над ним было удобнее производить преобразования
правила для синтаксических фраз (т.е. синтаксические правила) принимают аргументы в виде деревьев определенного типа 
(от фраз, на которые ссылается(через типы фраз) фраза этого правила)
	синтаксические правила могут менять род/число/другие_параметры у своих аргументов
	а также изменять например глаголы на причастия/деепричастия или производить другие преобразования
	все эти преобразования возможны за счет существующей базы данных целевого языка**

также каждое правило может генерировать разные тексты ОДНОГО И ТОГО ЖЕ СМЫСЛА, 
	выбор между которыми усуществляется случайным образом или с применением статистических методов
	чтобы не было повторов слов в переводе и фраз типа масло масленое, а также из каких-нибудь других эстетических соображений
(цель перевода - не создать произведение искусства на целевом языке, а наиболее четко передать смысл)

в конце может захотеться выбрать конечный порядок слов
	но это решается либо за счет создания вариантов одного правила (какой вариант будет выбран - не имеет значения)
	либо за счет создания разных правил с разным смыслом

=== простой пример ===
фраза (ф1)[big] имеет правило(п1), которое возвращает [большой] типа прил
фраза (ф2)[fat] имеет правила: (п2)[жирный] (п8)[полный] и (п9)[толсый] типа прил
фраза (ф3)[cat] имеет правила: (п3)[кошка] и (п4)[кот] типа сущ
фраза (ф4)[<прил> <суш>] имеет правило (п5)[[<прил (того же рода, что и сущ)>] <суш>] типа сущ
	также с ней ассоциировано, что при аргументах (ф2) в качестве прил и (ф3)в качестве сущ она должна заменяться на (ф5)
фраза (ф5)[fat cat] имеет правила: (п6)[[полная] кошка] и (п7)[[толстый] кот] 
текст [big fat cat] с памятью переводов ф5-п6 будет переводиться так:
	фраза ф4 требует прил, т.е. ф1 или ф2, сработает ф1 (а ф2 не сработает), и big будет прочитано
	далее ф4 требует сущ, т.е. ф3 или ф4 (ф5 еще не загружена)
		ф3 не может быть прочитано (fat != cat)
		пытаемся прочитать ф4, 
			она требует прил, т.е. ф1 или ф2, и сработает ф2 (а ф1 не сработает), и fat будет прочитана 
			далее ф4 требует сущ, т.е. ф3 или ф4 (ф5 еще не загружена), и сработает ф3 (а ф4, если все это еще раз проделать, не сработает), и будет прочитано cat
			так как это ф4 с аргументами ф2 и ф3, то она замениться на ф5 (можно даже повторно не парсить)
			
			ф5 по памяти переводов переводится правилом п6
		и возвращает [[полная] кошка] типа сущ, с атрибутом ж.р.
		ф1 имеет одно правило п1 и возвращает [большой] типа прил
	ф4 преобразовывает [большой] в ж.р. и возвращает [[большая] [[полная] кошка]]
		
=== в двух словах: ===
wiki переводчик с памятью переводов для разных текстов
переводчик на основе правил, 
	предоставляющий варианты выбора и делающий умные выборы вариантов по умолчанию (на основе памяти переводов)
	правила которого могут менять и добавлять пользователи
		варианты выбора нужны чтобы нек. фразу в одном тексте переводить одним способом, а в другом - другим

=== БД: ===
англ. слова
	ссылки на фразы, в которых они содержатся (вычисляется автоматически)
англ. фразы (частный случай - англ. слова)
	ссылки на правила перевода и на составные фразы
правила перевода
	ссылки из правил на ру_слова (однозначные) и/или на ру_слова с уточненным смысла + взаимозаменяемость
русские слова с уточненным смысла
	ссылка на (слово, склонение) + ссылка на wiki
русские слова
	разные склонения/спряжения, + ссылка на wiktionary
	+ ссылка на wiki, возможно disambiguition (неоднозначное)
	
** есть определенные взаимосвязи между __ == атрибуты у __, ссылающиеся на __
	где __ - ру_слова (однозначные) и/или ру_слова с уточненным смысла
это нужно для замен (в правилах) типа: пикирующий<->который пикирует

=== как можно организовать ===
т.к. много чего будет калиброваться на практике, нужен язык, позволяющий легко это делать
например лисп или джаваскрипт 
а также поддерживающий легкую работу с древовидными структурами

перевод осуществлять в браузере пользователя(джаваскрипт), а на сервере хранить только БД
на клиент загружаются
	все англ. фразы, в которых встречаются слова текста.
	и (все русские слова (возможно с уточненным смысла) и русские слова, на которые ссылаются русские слова с уточненным смысла)
	которые используются в правилах, на которые ссылаются фразы
		или обновляются (в LocalStorage браузера) те которые уже загружены и были изменены другими пользователями
		запросы типа: 
			вот набор этих слов - загрузить, 
			набор этих слов - обновить с этого момента, 
			а набор этих слов - обновить с того момента.
		может быть стоит сформировать набор самых употребляемых слов, и не передавать в запросе все слова
			а только указание этого набора и последнюю дату его обновления.

> сделать скрипт (аналогичный mathjax), который можно будет встраивать в сайты, который будет 
	создавать GUI, 
	при выборе фраз и правил - обращаться серверу этого сайта за памятью переводов страниц с этого сайта
	давать возможность копировать/инициализоровать память переводов
	при редактировании фраз и правил - обращаться к вики-серверу фраз и правил
> сделать отдельный проэкт - хранилище памяти переводов любого сайта, 
	тексты можно идентифицировать при помощи URI, и память переводов для них хранить на общем для всего мира сервере
	GUI - аналог гугл-переводчика сайтов
	и, возможно в дальнейшем, плагины к браузерам, которые будут внедрять исх. код в код страниц
	на сайтах, где разным пользователям выдается один и тот же контент, 
		клиент может отправлять на сервер не список всех слов текста, а только его URL, 
		а на сервере уже будут закэшированы слова из того текста.

редактирование и хранение слов и фраз удобно привязать к вики-движку, у которого для каждого типа слов и фраз надо сделать 
	отдельный способ отображения и редактирования wisiwig (исходный код можно хранить например в JSON формате)

----------------------------------------------------
распарсить словари
подключить SQLite
каждому правилу сопоставить id
каждое правило возвращает не результат, а функцию, куда еще что-то можно подставить
вконце парсинга в каждую функцию передавать дерево из id паттернов
	и дальше нейронка каждой ф-ции будет по этому дереву делать выбор
	